> GCC的基本原理，`REMB`（发送侧的拥塞），`TWCC`是什么
>  将拥塞控制放在发送端，好处在于能够识别到是否当前处于`ALR`状态，同时可以在发送端执行主动感知，这样可以少一个扩展头

> `quic`的重传逻辑是怎么样的，两种，一种是通过sack信息判断，另外一种是超时重传，其中超时的间隔应该指数上升的

>  `p2p`打洞的原理是什么，如何提升打洞的成功率
> 	 1. 完全锥形NAT：只要内网设备映射了一个端口，任何外部设备都可以访问该端口。
> 	 2. ​​受限锥形 NAT（Restricted Cone NAT）​​：只有之前通信过的外部 IP 才能访问映射的端口。
> 	 3. ​​端口受限锥形 NAT（Port-Restricted Cone NAT）​​：只有之前通信过的外部 IP 和端口才能访问映射的端口。
> 	 4. 对称 NAT（Symmetric NAT）​​：每次外部通信时，NAT 会分配一个新的端口，且映射关系与目标 IP 和端口相关。
>    打洞的流程
> 	 a. Peer A 和 Peer B 连接 STUN 服务器​，STUN会告诉每个peer他们自己的公网IP和端口
> 	 b. A和B通过信令服务器，交换彼此的公网地址和端口
> 	 c. A和B尝试相互通讯

>  `fec`的相关逻辑是怎么样的，比如说如何分包之类的

> 拥塞控制的几个优化方向
> 1. 识别出网络拥塞的类型，非拥塞时延/高CU
> 2. 结合业务
> 3. 结合信道信息
     > 核心就是通过获取更多信息，做出业务最优判断


>  `GCC cubic bbr`拥塞控制算法如何取舍
>  不同的业务可能会适合不同的拥塞控制算法，bbr的目标其实是最大化的带宽利用率，gcc其实就是最小化时延

> `JB`中哪些队列。这一块儿主要不是我负责，最重要的可能是接受队列，重排序队列，数据帧队列。

>  `volatile` `static` 关键字的作用是什么
#### 右值是什么，右值引用是什么，命名返回值优化
右值本质上是存储在寄存器或者栈上的临时空间，更像是一个表达式的结果。
"hello"是一个常量表达式，不是变量，所以没有地址，所以也就不能使用引用，比如右边就是编译错误`string& str1 = "hello";`
```c++
// 一种编译器优化技术，用于消除函数返回局部对象时的不必要的拷贝或移动操作，从而提升性能
struct Test {
    Test() { std::cout << "Constructor\n"; }
    Test(const Test&) { std::cout << "Copy Constructor\n"; }
    Test(Test&&) { std::cout << "Move Constructor\n"; }
    ~Test() { std::cout << "Destructor\n"; }
};

Test nrvo_test() {  // Named Return Value Optimization，命名返回值优化
    Test t; // 构造
    return t; // 可能无拷贝/移动
}

int main() {
    Test obj = nrvo_test(); // 期望只看到一次构造和一次析构，直接在obj对应的内存创建对象
    Test test2 = obj;  // 执行拷贝构造函数
    Test test3 = std::move(test1);  // 执行移动构造函数
    return 0;
}
```
##### 关于字符串常量表达式
```c++
    char str1[] = "helloworld";   // 这行代码的逻辑
```

std::move不移动数据，他只是类似于强转，把传入的左值(右值)转换成右值引用。真正的移动行为由`拷贝构造函数`或者`移动构造函数`执行
* `unique_ptr`的使用也非常以来右值引用，他本身禁用也拷贝复制和拷贝构造，如果要转移控制权，则要使用
  `std::unique_ptr<int> p2 = std::move(p1);  // 显式移动构造`
  执行完move操作之后，p1本身还是一个左值，因为它有名字，可以取地址，但它是一个“被移动过的对象”（moved-from object），不再保证有原来的值。
  move返回的对象是一个将亡值，因为它是一个即将被“移动”（资源被“窃取”）的对象的引用。


>优先使用make_unique这种语句，该语句保证了单次调用线程的安全性。因为new和赋值操作本身不是原子的，所以多线程问题是有可能的
另外，make_unique的控制块和对象的创建是在一起的，两次创建可能会影响性能

> 如果领导问的两个拥塞控制算法是的怎么影响时延的就聚焦在拥塞控制算法的不同上，比如说所有的领导都会问，bbr和GCC的区别是什么。BBR找到是最大的时延带宽积，在碰到抖动的情况，接受码率可能是偏大的，这个时候的时延带宽积也可能偏大，但是GCC碰到时延波动的情况可能是当前带宽的0.85，降得会更低一点。

>使用quic的作用是什么?
>	1. 连接级别的信息统统都放到了quic里面，比如统一的quic包头，连接级的丢包，rtt等
>2. 利用了quic对于所有数据包的一些操作，比如如果想要给所有的数据包添加一个timestamp帧头，可以很方便的在quic里面添加一个帧类型。
>3. 也是利用了quic的帧的形式，可以有一些联合打包的特性，比如说将音频的数据包和feedback/ack进行联合打包，提升在极低带宽场景下的带宽利用率

##### 循环展开
核心思路就是优化循环里面的操作，比如如下代码是循环展开的一个代码
```c++
    for (int i=0; i<8; i++) {  // 循环展开前
	    printf("Hello\n"); //print hello 5 times
    }

	for (int i=0; i<2; i++) {  // 循环展开，将一部分多次循环相关的操作放到单次循环中，减少循环判断次数
		printf("Hello\n");
		printf("Hello\n");
		printf("Hello\n");
		printf("Hello\n");
	}
```

> 排序算法，快排之类的，常见的容器

> map的中括号和insert有什么区别
> 如果map中已经存在了对应的元素，则insert会失败，会有对应的返回值告知当前是失败的状态

> 编码前丢帧。长期参考帧，桌面流超发特性

> for循环展开，比如两个数组，求这两个数组的相加之后的数组结果

> 二叉树的序列化和反序列化

> 模板函数不可以是虚函数。虚函数需要一个统一的vtable条目，但是模板函数会在编译的过程中生成若干个参数不同的独立函数，无法在编译时确定一个固定的 vtable 条目，所以模板函数不可以是虚函数

> linux中的进程通信：
> 1. 管道： | ，通过系统调用实现进程间通讯   2. 信号：比如Ctrl + C  3. 消息队列    4.共享内存   4.信号量    5. 套接字/本地socket无需经过网络协议栈